# Refactoring

## CH 03 코드에서 나는 악취

### 3.1 기이한 이름(Mysterious Name)

- 코드를 명료하게 표현하는 데 가장 중요한 요소는 바로 이름이다.
- 이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써야 한다.
- 마땅한 이름이 떠오르지 않는다면, 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
- 이름을 잘 정리하다보면 코드가 훨씬 간결해질 때가 많다.

### 3.2 중복 코드(Duplicated Code)

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
- 중복 내용이 있다면 함수로 추출하여 사용한다.
- 비슷한데 완전 같지 않다면, 문장을 슬라이드하여 비슷한 부분을 한 곳에 모아 함수로 추출한다.
- 서브 클래스에 중복 내용이 있다면, 메서드 올려 부모로 옮긴다.

### 3.3 긴 함수(Long Function)

- 짧은 함수는 간접 호출(indirection)의 효과, 즉 코드를 이해하고 공유하고 선택하기 쉬워진다.
- 예전에는 서브루틴을 호출하는 비용이 컸지만, 요즘 언어는 함수 호출 비용을 거의 없애버렸다.
- 주석을 달아야 할 만한 부분은 무조건 함수로 만들고, 함수 이름은 동작 방식이 아닌 의도(intention)가 드러나게 짓는다.
- 무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.
- 함수가 매개변수와 임시 변수를 많이 사용한다면 추출하는데 방해가 된다.
  - 임시 변수를 질의 함수로 바꾸거나, 매개변수 객체 만들기와 객체 통째로 넘기기로 매개변수의 수를 줄일 수 있다.
- 코드가 단 한 줄이어도 따로 설명할 필요가 있다면 함수로 추출하는 게 좋다.
- 조건문이나 반복문도 추출 대상의 실마리를 제공한다.

### 3.4 긴 매개변수 목록(Long Parameter List)

- 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다.
- 매개변수 중 다른 매개변수로 값을 얻어올 수 있는데 매개변수가 있는데, 이를 매개변수를 질의 함수로 바꾸기로 제거한다.
- 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기로 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 매개변수 객체 만들기로 하나로 묶는다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기로 없애준다.
- 여러 개의 함수가 특정 매개변수들의 갑슬 공통으로 사용할 때는, 여러 함수를 클래스로 묶기를 이용하여 공통 값들을 클래스 필드로 정의한다.
  - 함수형 프로그래밍이라면 일련의 부분 적용 함수(partially applied function)들을 생성한다.

### 3.5 전역 데이터(Global Data)

- 전역 데이터는 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없어, 버그의 원인이 된다.
- 이를 방지하기 위해 변수를 캡슐화한다.

### 3.6 가변 데이터(Mutable Data)

- 함수형 프로그래밍에서 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다.
- 변수 캡슐화하기를 적용하여 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드를 개선하기 쉽다.
- 하나의 변수에 용도별로 독립 변수에 저장하느라 값을 갱신하는 경우라면 변수 쪼개기를 이용하여 용도별로 독립 변수에 저장하게 하여 값 갱신이 문제를 일으킬 여지를 없앤다.
- 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다.
  - 문장 슬라이드하기와 함수 추출하기를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다.
- API를 만들 때는 질의 함수와 변경 함수 분리하기를 활용해서 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
- 가능한 한 세터 제거하기도 적용한다.
  - 세터를 호출하는 클라리언트를 찾는 것만으로도 변수의 유효 범위를 줄이는 데 도움될 때가 있다.
- 값을 다른 곳에서 설정할 수 있는 가변 데이터는 파생 변수를 질의 함수로 바꾼다.
- 변수의 유효 범위가 넓어지면, 여러 함수를 클래스로 묶기나, 여러 함수를 변환 함수로 묶기를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한한다.
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수라면, 참조를 값으로 바꾸기를 적용하여 내부 필드를 직접 수정하지 말고 구조체를 통째로 교체하는 편이 낫다.

### 3.7 뒤엉킨 변경(Divergent Change)

- 뒤엉킨 변경은 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.
- 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달하게 하는 식으로 단계를 분리한다.
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다.

### 3.8 산탄총 수술(Shotgun Surgery)

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 발생한다.
- 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어둔다.
- 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는 데 개의치 않는다.

### 3.9 기능 편애(Feature Envy)

- 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 많을 때 발생한다.
  - 모듈 안에서의 상호작용은 늘리고, 모듈 간의 상호작용을 줄여야 하는데, 이를 제대로 이루어지지 않는 경우 발생한다.
- 해당 함수가 원하는 적절한 모듈로 옮긴다.

### 3.10 데이터 뭉치(Data Clumps)

- 데이터는 뭉쳐다니는 경향이 있으며, 이런 경우 하나의 클래스로 묶는다.
  - 클래스로 묶으면, 종종 상당한 중복을 없애고 향후 개발을 가속하는 유용한 클래스로 이어지기도 한다.

### 3.11 기본형 집착(Primitive Obsession)

- 기본형만 고집하지말고, 클래스로 만들어서 사용한다.
  - 기본형을 객체로 바꾸기를 적용한다.
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드로 쓰였다면 타입 코드와 서브클래스로 바꾸기와 조건부 로직을 다형성으로 바꾸기를 차례로 적용한다.

### 3.12 반복되는 switch문(Repeated Switches)

- 초기에는 다형성 문제로 switch문을 문제로 인식했다.
  - 현재는 다형성이 널리 자리를 잡아 switch문을 문제로 삼지 않는다.
- 중복되는 switch문이 문제이다.
  - 조건절을 하나 추가할 때마다 다른 switch문도 모두 찾아서 수정해야 하기 때문이다.
    - 다형성을 사용하여 이러한 문제를 해결한다.

### 3.13 반복문(Loops)

- 현재 일급 함수를 지원하는 언어는 많아졌으며, filter나 map과 같은 반복문을 파이프라인으로 바꾸기로 반복문을 제거한다.

### 3.14 성의 없는 요소(Lazy Element)

- 구조를 잡기 위해 사용한 프로그램 요소가 필요없어 보인다면, 인라인으로 처리한다.
  - 상속을 사용했다면 계층 합치기를 적용한다.

### 3.15 추측성 일반화(Speculative Generality)

- 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않다면 쓸데없는 낭비이다.
- 하는 일이 없는 추상 클래스는 계층 합치기로 제거하고, 쓸데없이 위임하는 코드는 인라인으로 삭제한다.

### 3.16 임시 필드(Temporary Field)

- 특정 상황에서만 값이 설정되는 필드를 가진 클래스는, 사용자로 하여금 필드가 존재하는 이유를 이해하기 어렵게 한다.
  - 이런 필드들은 클래스 추출하기로 옮겨주고, 관련 함수도 같이 옮겨둔다.
  - 이런 필드의 유효성 체크 로직은 '유효하지 않은 경우'를 위한 대안 클래스를 만들어 제거한다.

### 3.17 메시지 체인(Message Chains)

- 객체를 통해 다른 객체를 얻는 과정이 연쇄적으로 이어질 때 발생한다.
  - 클라이언트가 객체 내비게이션 구조에 종속됐음을 의미한다.
- 적절하게 함수를 추출하고, 옮겨 체인을 숨긴다.

### 3.18 중개자(Middle Man)

- 클래스가 다른 클래스에 구현을 위임하는 '중간 역할'만을 하고 있다면 직접 소통하도록 바꾼다.

### 3.19 내부자 거래(Insider Trading)

- 모듈 사이에 데이터 거래가 많으면 결합도(coupling)가 높아진다.
  - 함수 옮기기와 필드 옮기기로 결합도를 낮춘다.
  - 여러 모듈이 같은 관심사를 공유한다면, 제 3의 모듈을 만들거나 위임 숨기기로 중간자 역할을 하게 만든다.
- 상속 구조에서 자식 클래스가 부모 클래스를 많이 접근한다면, 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용한다.

### 3.20 거대한 클래스(Large Class)

- 클래스가 너무 많은 일을 하려다 보면 필드 수가 상당히 늘어나고 중복 코드가 생기기 쉽다.
  - 클래스 추출하기로 필드들 일부를 따로 묶는다.
    - 분리한 컴포넌트를 원래 클래스와 상속 관계로 만드는 게 좋다면 슈퍼클래스 추출하기나 타입 코드를 서브클래스로 바꾸기를 적용한다.
- 코드량이 너무 많은 클래스는 그 안에서 자체적으로 중복을 제거한다.
