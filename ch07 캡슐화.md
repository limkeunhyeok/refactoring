# Refactoring

## CH 07 캡슐화

### 7.1 레코드 캡슐화하기(Encapsulate Record)

```javascript
// before
organization = { name: "애크미 구스베리", contry: "GB" };

// after
class Organization {
  constructor(data) {
    this._name = data.name;
    this._contry = data.country;
  }

  get name() {
    return this._name;
  }

  set name(arg) {
    this._name = arg;
  }

  get country() {
    return this._country;
  }

  set country(arg) {
    this._country = arg;
  }
}
```

> 레코드는 연관된 여러 데이터를 직관적인 방식으로 묶을 수 있어서 각각을 따로 취급할 때보다 훨씬 의미 있는 단위로 전달할 수 있게 해준다. 가변 데이터리면 객체를 사용한다.

#### 절차

1. 레코드를 담은 변수를 캡슐화한다.
2. 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다.
3. 테스트한다.
4. 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
5. 레코드를 반환하는 예전 함수를 사용하는 코드를 4에서 만든 새 함수로 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때마다 테스트한다.
6. 클래스에서 원본 데이터를 반환하는 접근자와 원본 레코드를 반환하는 함수들을 제거한다.
7. 테스트한다.
8. 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.

### 7.2 컬렉션 캡슐화하기(Encapsulate Collection)

```javascript
// before
class Person {
  get courses() {
    return this._courses;
  }

  set courses(aList) {
    this._courses = aList
  }
}

// after
class Person {
  get courses() {
    return this._courses.slice();
  }

  addCourses(acourses) { ... }

  removeCourses(acourses) { ... }
}
```

> 가변 데이터를 모두 캡슐화하면 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬우며, 필요한 시점에 데이터 구조를 변경하기도 쉬워진다. 게터가 원본 컬렉션을 반환하지 않게 만들어서 클라이언트가 실수로 컬렉션을 바꿀 가능성을 차단하는 게 낫다.

#### 절차

1. 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기부터 시작한다.
2. 컬렉션에 원소를 추가/제거하는 함수를 추가한다.
3. 정적 검사를 수행한다.
4. 컬렉션을 참조하는 부분을 모두 찾는다. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다. 하나씩 수정할 때마다 테스트한다.
5. 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기 전용 프락시나 복제본을 반환하게 한다.
6. 테스트한다.
